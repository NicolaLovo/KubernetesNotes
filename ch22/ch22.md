# Chapter 22 - Kubernetes Authentication and Authorization

How is the kubernetes control plane authorize me to perform some actions?

- when calling kubectl it passes the client certificate, the server version... -> all stored in the kubeconfig file

It is stored in the `$HOME/.kube` folder in the home directory. Or use the command: `kubectl config view`

Explicitly use a kubeconfig file:

- `kubectl get pod --kubeconfig MY_KUBECONFIG` -> useful if I have many kubeconfig files

Parts of kubeconfig:

- list of contexts -> with cluster, user and name
- list of users -> name, client-certificate-data (base64 encoded), client-key-data
- list of clusters -> certificate authority

Authentication vs authorization:

- authentication -> who you are
- authorization -> what you can do. In Kubernetes we have these methods
  - ABAC (Attribute Based Access Control) -> requires the apiServer to be restarted (not very used)
  - RBAC (Role Based Access Control) -> based on roles, de facto standard
  - NODE-based authorization -> used by nodes to interact between each other
  - Webhook -> use a 3rd party system that does the access control for kubernetes

See the apiServer:

1. ssh in the control plane
2. `cd /etc/kubernetes/manifests` -> yaml of static pods
3. `cat kube-apiserver.yaml`
   1. `--authorization-mode` parameter, typically set to `--authorization-mode=Node,RBAC`. It determines the order with which the access control mechanism is used -> check first Node authz, then RBAC
      1. **If not specified, it will default to AlwaysAllow**
      2. other options include `AlwaysDeny`
   2. `--client-ca-file`

So the ApiServer defines the authz mechanism on the cluster depending on the parameters.

`cd /etc/kubernetes/pki` -> stores all certificate files in kubernetes

- `apiserver.key`, `apiserver.crt` -> used when the apiserver interacts with etcd, scheduler(...): in this context the apiserver is a client and so needs a certificate and keys