# Chapter 19 - Manage TLS Certificates

Communication between master (`kube-api-server`) and worker (`kubelet`) nodes must be encrypted and secure. 

- master -> worker communication: master is the "client", worker is the "server"

Also the communication between an external user-master node must be secure.

Other client->server pairs:

- `kube-apiserver` -> `ETCD`/`kubelet`:
- `scheduler`->`kube-apiserver`
- `controller`->`kube-apiserver`
- `kube-proxy`->`kube-apiserver`

Ideally each of these components should have a certificate and a private key.

Common names for certificates are:

- server.crt
- server.pem
- client.cert
- client.pem

Common names for private keys are:

- server.key
- server-key.pem
- client.key
- client-key.pem

## Certificate orchestration

### Certificate for the user

Used to provide access to the cluster to a user

```sh
# generate a RSA key pair
openssl genrsa -out adam.key 2048
# create a certificate signing request for Adam's key
openssl req -new -key adam.key -out adam.csr -subj "CN=adam"
# convert certificate signing request to base64 for the .yaml
cat adam.csr | base64
```

Now we need to ask kubernetes to approve that certificate (`csr.yaml`)

- `kubectl get csr` -> get all certificate signing requests

Now we will use an internal CA inside the certificate -> uses the internal private key to sign the requests.

Now wait for an admin to approve/deny the request:

- `kubectl certificate approve adam`

Retrieve the newly generated certificate:

- `kubectl get csr adam -o yaml > issuecert.yaml`
- it will be in base64, we need to decode it:
  - `echo "CERT_COPIED_FROM_YAML" | base64 -d`

Now the user can add it and use it for RBAC (see next chapter).